<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      About Firmware
    </title>
    <link rel="stylesheet" type="text/css" href="../stylesheets/lfs.css" />
    <meta name="generator" content="DocBook XSL-NS Stylesheets Vsnapshot" />
    <style type="text/css">
    /*<![CDATA[*/
    body { background-image: url('images/draft.png');
       background-repeat: no-repeat;
       background-position: top left;
       /* The following properties make the watermark "fixed" on the page. */
       /* I think that's just a bit too distracting for the reader... */
       /* background-attachment: fixed; */
       /* background-position: center center; */
     }
    /*]]>*/
    </style>
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body class="blfs" id="blfs-r12.0-1048+">
    <div class="navheader">
      <h4>
        Beyond Linux<sup>®</sup> From Scratch <span class="phrase">(System
        V</span> 版) - Version r12.0-1048+
      </h4>
      <h3>
        第3章 LFS 設定以降について
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="console-fonts.html" title=
          "About Console Fonts">戻る</a>
          <p>
            About Console Fonts
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="devices.html" title="デバイスに関して">次へ</a>
          <p>
            デバイスに関して
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="config.html" title=
          "第3章 LFS 設定以降について">上に戻る</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Beyond Linux® From Scratch    (System V 版) - Version r12.0-1048+">ホーム</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="ja" xml:lang="ja">
      <h1 class="sect1">
        <a id="postlfs-firmware" name="postlfs-firmware"></a>About Firmware
      </h1>
      <p>
        On some recent PCs it can be necessary, or desirable, to load
        firmware to make them work at their best. There is a directory,
        <code class="filename">/lib/firmware</code>, where the kernel or
        kernel drivers look for firmware images.
      </p>
      <p>
        Currently, most firmware can be found at a <strong class=
        "userinput"><code>git</code></strong> repository which can be viewed
        in the browser with the URL <a class="ulink" href=
        "https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain">
        https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain</a>.
        For convenience, the LFS Project has created a mirror, updated daily,
        where these firmware files can be accessed via <strong class=
        "userinput"><code>wget</code></strong> or a web browser at <a class=
        "ulink" href=
        "https://anduin.linuxfromscratch.org/BLFS/linux-firmware/">https://anduin.linuxfromscratch.org/BLFS/linux-firmware/</a>.
      </p>
      <p>
        To get the firmware, either point a browser to one of the above
        repositories and then download the item(s) which you need. If you
        want all these firmware files (for example you are distributing the
        system onto multiple hardware systems), install <a class="xref" href=
        "../general/git.html" title="Git-2.43.0">git-2.43.0</a> and clone
        <a class="ulink" href=
        "https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git">
        https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git</a>,
        or open this URL in a browser and download the latest snapshot listed
        in the <code class="literal">Tag</code> table.
      </p>
      <p>
        For some other firmware, particularly for Intel microcode and certain
        wifi devices, the needed firmware is not available in the above
        repository. Some of this will be addressed below, but a search of the
        Internet for needed firmware is sometimes necessary.
      </p>
      <p>
        Firmware files are conventionally referred to as blobs because you
        cannot determine what they will do. Note that firmware is distributed
        under various different licenses which do not permit disassembly or
        reverse-engineering.
      </p>
      <p>
        Firmware for PCs falls into four categories:
      </p>
      <div class="itemizedlist">
        <ul class="compact">
          <li class="listitem">
            <p>
              Updates to the CPU to work around errata, usually referred to
              as microcode.
            </p>
          </li>
          <li class="listitem">
            <p>
              Firmware for video controllers. On x86 machines this is
              required for ATI devices (Radeon and AMDGPU chips) and may be
              useful for Intel (Skylake and later) and Nvidia (Kepler and
              later) GPUs.
            </p>
            <p>
              ATI Radeon and AMDGPU devices all require firmware to be able
              to use KMS (kernel modesetting - the preferred option) as well
              as for Xorg. For old radeon chips (before the R600), the
              firmware is still in the kernel source.
            </p>
            <p>
              Intel integrated GPUs from Skylake onwards can use firmware for
              GuC (the Graphics microcontroller), and also for the HuC
              (HEVC/H265 microcontroller which offloads to the GPU) and the
              DMC (Display Microcontroller) to provide additional low-power
              states. The GuC and HuC have had a chequered history in the
              kernel and updated firmware may be disabled by default,
              depending on your kernel version. Further details may be found
              at <a class="ulink" href=
              "https://01.org/linuxgraphics/downloads/firmware/">01.org</a>
              and <a class="ulink" href=
              "https://wiki.archlinux.org/index.php/intel_graphics">Arch
              linux</a>.
            </p>
            <p>
              Nvidia GPUs from Kepler onwards require signed firmware,
              otherwise the nouveau driver is unable to provide hardware
              acceleration. Nvidia has now released firmware up to Ampere
              (GeForce30 series) to linux-firmware. Note that faster clocks
              than the default are not enabled by the released firmware.
            </p>
          </li>
          <li class="listitem">
            <p>
              Firmware updates for wired network ports. Most of them work
              even without the updates, but they will probably work better
              with the updated firmware. For some modern laptops, firmware
              for both wired ethernet (e.g. rtl_nic) and also for bluetooth
              devices (e.g. qca) is <span class=
              "emphasis"><em>required</em></span> before the wired network
              can be used.
            </p>
          </li>
          <li class="listitem">
            <p>
              Firmware for other devices, such as wireless NICs. These
              devices are not required for the PC to boot, but need the
              firmware before these devices can be used.
            </p>
          </li>
        </ul>
      </div>
      <div class="admon note">
        <img alt="[注記]" src="../images/note.png" />
        <h3>
          注記
        </h3>
        <p>
          Although not needed to load a firmware blob, the following tools
          may be useful for determining, obtaining, or preparing the needed
          firmware in order to load it into the system: <a class="xref" href=
          "../general/cpio.html" title="cpio-2.14">cpio-2.14</a>, <a class=
          "xref" href="../general/git.html" title=
          "Git-2.43.0">git-2.43.0</a>, <a class="xref" href=
          "../general/pciutils.html" title=
          "pciutils-3.10.0">pciutils-3.10.0</a>, and <a class="xref" href=
          "../basicnet/wget.html" title="Wget-1.21.4">Wget-1.21.4</a>
        </p>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="cpu-microcode" name="cpu-microcode"></a>Microcode updates
          for CPUs
        </h2>
        <p>
          In general, microcode can be loaded by the BIOS or UEFI, and it
          might be updated by upgrading to a newer version of those. On
          linux, you can also load the microcode from the kernel if you are
          using an AMD family 10h or later processor (first introduced late
          2007), or an Intel processor from 1998 and later (Pentium4, Core,
          etc), if updated microcode has been released. These updates only
          last until the machine is powered off, so they need to be applied
          on every boot.
        </p>
        <p>
          Intel provide updates of their microcode for Skylake and later
          processors as new vulnerabilities come to light, and have in the
          past provided updates for processors from SandyBridge onwards,
          although those are no-longer supported for new fixes. New versions
          of AMD firmware are rare and usually only apply to a few models,
          although motherboard manufacturers get AGESA (AMD Generic
          Encapsulated Software Architecture) updates to change BIOS values,
          e.g. to support more memory variants, new vulnerability fixes or
          newer CPUs.
        </p>
        <p>
          There were two ways of loading the microcode, described as 'early'
          and 'late'. Early loading happens before userspace has been
          started, late loading happens after userspace has started. However,
          late loading is known to be problematic and not supported anymore
          (see the kernel commit <a class="ulink" href=
          "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d23d33e">
          x86/microcode: Taint and warn on late loading</a>.) Indeed, early
          loading is needed to work around one particular erratum in early
          Intel Haswell processors which had TSX enabled. (See <a class=
          "ulink" href=
          "https://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwelly/">
          Intel Disables TSX Instructions: Erratum Found in Haswell,
          Haswell-E/EP, Broadwell-Y</a>.) Without this update glibc can do
          the wrong thing in uncommon situations.
        </p>
        <p>
          In previous versions of this book, late loading of microcode to see
          if it gets applied was recommended, followed by using an initrd to
          force early loading. But now that the contents of the Intel
          microcode tarball is documented, and AMD microcode can be read by a
          Python script to determine which machines it covers, there is no
          real reason to use late loading.
        </p>
        <p>
          It might be still possible to manually force late loading of
          microcode. But it may cause kernel malfunction and you should take
          the risk yourself. You will need to reconfigure your kernel for
          late loading, but early loading is always supported by Linux kernel
          version 6.6 or later on a x86 (no matter 32-bit or 64-bit) system.
          The instructions here will show you how to create an initrd for
          early loading. It is also possible to build the same microcode bin
          file into the kernel, which allows early loading but requires the
          kernel to be recompiled to update the microcode.
        </p>
        <p>
          To confirm what processor(s) you have (if more than one, they will
          be identical) look in /proc/cpuinfo. Determine the decimal values
          of the cpu family, model and stepping by running the following
          command (it will also report the current microcode version):
        </p>
        <pre class="userinput"><kbd class=
        "command">head -n7 /proc/cpuinfo</kbd></pre>
        <p>
          Convert the cpu family, model and stepping to pairs of hexadecimal
          digits, and remember the value of the <span class=
          "quote">「<span class="quote">microcode</span>」</span> field. You
          can now check if there is any microcode available.
        </p>
        <p>
          If you are creating an initrd to update firmware for different
          machines, as a distro would do, go down to 'Early loading of
          microcode' and cat all the Intel blobs to GenuineIntel.bin or cat
          all the AMD blobs to AuthenticAMD.bin. This creates a larger initrd
          - for all Intel machines in the 20200609 update the size was 3.0 MB
          compared to typically 24 KB for one machine.
        </p>
        <div class="sect3" lang="ja" xml:lang="ja">
          <h3 class="sect3">
            <a id="intel-microcode" name="intel-microcode"></a>
          </h3>
          <h4 class="title">
            <a id="intel-microcode" name="intel-microcode"></a>Intel
            Microcode for the CPU
          </h4>
          <p>
            The first step is to get the most recent version of the Intel
            microcode. This must be done by navigating to <a class="ulink"
            href=
            "https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/">
            https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/</a>
            and downloading the latest file there. As of this writing the
            most secure version of the microcode is microcode-20231114.
            Extract this file in the normal way, the microcode is in the
            <code class="filename">intel-ucode</code> directory, containing
            various blobs with names in the form XX-YY-ZZ. There are also
            various other files, and a releasenote.
          </p>
          <p>
            In the past, intel did not provide any details of which blobs had
            changed versions, but now the releasenote details this. You can
            compare the microcode version in <code class=
            "filename">/proc/cpuinfo</code> with the version for your CPU
            model in the releasenote to know if there is an update.
          </p>
          <p>
            The recent firmware for older processors is provided to deal with
            vulnerabilities which have now been made public, and for some of
            these such as Microarchitectural Data Sampling (MDS) you might
            wish to increase the protection by disabling hyperthreading, or
            alternatively to disable the kernel's default mitigation because
            of its impact on compile times. Please read the online
            documentation at <a class="ulink" href=
            "https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html">
            https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html</a>.
          </p>
          <p>
            For an Tigerlake mobile (described as Intel(R) Core(TM) i5-11300H
            CPU) the relevant values are cpu family 6, model 140, stepping 1
            so in this case the required identification is 06-8c-01. The
            releasenote says the latest microcode for it is versioned 0xb4.
            If the value of the <span class="quote">「<span class=
            "quote">microcode</span>」</span> field in <code class=
            "filename">/proc/cpuinfo</code> is 0xb4 or greater, it indicates
            the microcode update is already applied by the BIOS. Otherwise,
            proceed to <a class="xref" href="firmware.html#early-microcode"
            title="Early loading of microcode">「Early loading of
            microcode」</a>.
          </p>
        </div>
        <div class="sect3" lang="ja" xml:lang="ja">
          <h3 class="sect3">
            <a id="amd-microcode" name="amd-microcode"></a>
          </h3>
          <h4 class="title">
            <a id="amd-microcode" name="amd-microcode"></a>AMD Microcode for
            the CPU
          </h4>
          <p>
            Begin by downloading a container of firmware for your CPU family
            from <a class="ulink" href=
            "https://anduin.linuxfromscratch.org/BLFS/linux-firmware/amd-ucode/">
            https://anduin.linuxfromscratch.org/BLFS/linux-firmware/amd-ucode/</a>.
            The family is always specified in hex. Families 10h to 14h (16 to
            20) are in microcode_amd.bin. Families 15h, 16h, 17h (Zen, Zen+,
            Zen2) and 19h (Zen3) have their own containers, but very few
            machines are likely to get updated microcode. Instead, AMD
            provide an updated AGESA to the motherboard makers, who may
            provide an updated BIOS using this. There is a Python3 script at
            <a class="ulink" href=
            "https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py">
            https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py</a>.
            Download that script and run it against the bin file to check
            which processors have updates.
          </p>
          <p>
            For the very old Athlon(tm) II X2 in these examples the values
            were cpu family 16, model 5, stepping 3 giving an identification
            of Family=0x10 Model=0x05 Stepping=0x03. One line of the
            <span class="command"><strong>amd_ucode_info.py</strong></span>
            script output describes the microcode version for it:
          </p>
          <pre class="screen"><code class=
          "computeroutput">Family=0x10 Model=0x05 Stepping=0x03: Patch=0x010000c8 Length=960 bytes</code></pre>
          <p>
            If the value of the <span class="quote">「<span class=
            "quote">microcode</span>」</span> field in <code class=
            "filename">/proc/cpuinfo</code> is 0x10000c8 or greater, it
            indicates the BIOS has already applied the microcode update.
            Otherwise, proceed to <a class="xref" href=
            "firmware.html#early-microcode" title=
            "Early loading of microcode">「Early loading of microcode」</a>.
          </p>
        </div>
        <div class="sect3" lang="ja" xml:lang="ja">
          <h3 class="sect3">
            <a id="early-microcode" name="early-microcode"></a>
          </h3>
          <h4 class="title">
            <a id="early-microcode" name="early-microcode"></a>Early loading
            of microcode
          </h4>
          <p>
            If you have established that updated microcode is available for
            your system, it is time to prepare it for early loading. This
            requires an additional package, <a class="xref" href=
            "../general/cpio.html" title="cpio-2.14">cpio-2.14</a> and the
            creation of an initrd which will need to be added to grub.cfg.
          </p>
          <p>
            It does not matter where you prepare the initrd, and once it is
            working you can apply the same initrd to later LFS systems or
            newer kernels on this same machine, at least until any newer
            microcode is released. Use the following commands:
          </p>
          <pre class="userinput"><kbd class=
          "command">mkdir -p initrd/kernel/x86/microcode
cd initrd</kbd></pre>
          <p>
            For an AMD machine, use the following command (replace
            &lt;MYCONTAINER&gt; with the name of the container for your CPU's
            family):
          </p>
          <pre class="userinput"><kbd class=
          "command">cp -v ../&lt;MYCONTAINER&gt; kernel/x86/microcode/AuthenticAMD.bin</kbd></pre>
          <p>
            Or for an Intel machine copy the appropriate blob using this
            command:
          </p>
          <pre class="userinput"><kbd class=
          "command">cp -v ../intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</kbd></pre>
          <p>
            Now prepare the initrd:
          </p>
          <pre class="userinput"><kbd class=
          "command">find . | cpio -o -H newc &gt; /boot/microcode.img</kbd></pre>
          <p>
            You now need to add a new entry to /boot/grub/grub.cfg and here
            you should add a new line after the linux line within the stanza.
            If /boot is a separate mountpoint:
          </p>
          <pre class="userinput"><kbd class=
          "command">initrd /microcode.img</kbd></pre>
          <p>
            or this if it is not:
          </p>
          <pre class="userinput"><kbd class=
          "command">initrd /boot/microcode.img</kbd></pre>
          <p>
            If you are already booting with an initrd (see <a class="xref"
            href="initramfs.html" title="initramfs について">「initramfs
            について」</a>), you should run <span class=
            "command"><strong>mkinitramfs</strong></span> again after putting
            the appropriate blob or container into <code class=
            "filename">/lib/firmware</code>. More precisely, put an intel
            blob in a <code class="filename">/lib/firmware/intel-ucode</code>
            directory or an AMD container in a <code class=
            "filename">/lib/firmware/amd-ucode</code> directory before
            running <span class=
            "command"><strong>mkinitramfs</strong></span>. Alternatively, you
            can have both initrd on the same line, such as <strong class=
            "userinput"><code>initrd /microcode.img
            /other-initrd.img</code></strong> (adapt that as above if /boot
            is not a separate mountpoint).
          </p>
          <p>
            You can now reboot with the added initrd, and then use the
            following command to check that the early load worked:
          </p>
          <pre class="userinput"><kbd class=
          "command">dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</kbd></pre>
          <p>
            If you updated to address vulnerabilities, you can look at the
            output of the <span class="command"><strong>lscpu</strong></span>
            command to see what is now reported.
          </p>
          <p>
            The places and times where early loading happens are very
            different in AMD and Intel machines. First, an example of an
            Intel (Tigerlake mobile) with early loading:
          </p>
          <pre class="screen"><code class=
          "literal">[    0.000000] microcode: microcode updated early: 0x86 -&gt; 0xb4, date = 2023-09-07
[    0.000000] Linux version 6.6.1 (xry111@stargazer) (gcc (GCC) 13.2.0, GNU ld (GNU Binutils) 2.41) #36 SMP PREEMPT_DYNAMIC Tue Nov 14 01:56:04 CST 2023
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-6.6.1 root=PARTUUID=<em class="replaceable"><code>&lt;CLASSIFIED&gt;</code></em> ro
[    0.424002] microcode: Microcode Update Driver: v2.2.</code></pre>
          <p>
            A historic AMD example:
          </p>
          <pre class="screen"><code class=
          "literal">[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</code></pre>
        </div>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="video-firmware" name="video-firmware"></a>Firmware for Video
          Cards
        </h2>
        <div class="sect3" lang="ja" xml:lang="ja">
          <h3 class="sect3">
            <a id="ati-video-firmware" name="ati-video-firmware"></a>
          </h3>
          <h4 class="title">
            <a id="ati-video-firmware" name="ati-video-firmware"></a>Firmware
            for ATI video chips (R600 and later)
          </h4>
          <p>
            These instructions do NOT apply to old radeons before the R600
            family. For those, the firmware is in the kernel's <code class=
            "filename">/lib/firmware/</code> directory. Nor do they apply if
            you intend to avoid a graphical setup such as Xorg and are
            content to use the default 80x25 display rather than a
            framebuffer.
          </p>
          <p>
            Early radeon devices only needed a single 2K blob of firmware.
            Recent devices need several different blobs, and some of them are
            much bigger. The total size of the radeon firmware directory is
            over 500K — on a large modern system you can probably spare the
            space, but it is still redundant to install all the unused files
            each time you build a system.
          </p>
          <p>
            A better approach is to install <a class="xref" href=
            "../general/pciutils.html" title=
            "pciutils-3.10.0">pciutils-3.10.0</a> and then use <strong class=
            "userinput"><code>lspci</code></strong> to identify which VGA
            controller is installed.
          </p>
          <p>
            With that information, check the RadeonFeature page of the Xorg
            wiki for <a class="ulink" href=
            "https://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder ring
            for engineering vs marketing names</a> to identify the family
            (you may need to know this for the Xorg driver in BLFS — Southern
            Islands and Sea Islands use the radeonsi driver) and the specific
            model.
          </p>
          <p>
            Now that you know which controller you are using, consult the
            <a class="ulink" href=
            "https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</a> page of
            the Gentoo wiki which has a table listing the required firmware
            blobs for the various chipsets. Note that Southern Islands and
            Sea Islands chips use different firmware for kernel 3.17 and
            later compared to earlier kernels. Identify and download the
            required blobs then install them:
          </p>
          <pre class="userinput"><kbd class=
          "command">mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</kbd></pre>
          <p>
            Building the kernel amdgpu driver as a module is recommended
            because the firmware files need to be accessible at the time it
            is loaded. If you are building it as a part of the kernel image
            for any reason, you need to either include the firmware files in
            the initramfs (read <a class="xref" href="initramfs.html" title=
            "initramfs について">「initramfs について」</a> for details), or include
            them in the kernel image itself (read <a class="xref" href=
            "firmware.html#firmware-in-kernel-image" title=
            "Include Firmware Blobs in the Kernel Image">「Include Firmware
            Blobs in the Kernel Image」</a> for details).
          </p>
        </div>
        <div class="sect3" lang="ja" xml:lang="ja">
          <h3 class="sect3">
            <a id="amdgpu-video-firmware" name="amdgpu-video-firmware"></a>
          </h3>
          <h4 class="title">
            <a id="amdgpu-video-firmware" name=
            "amdgpu-video-firmware"></a>Firmware for AMD/ATI amdgpu video
            chips
          </h4>
          <p>
            All video controllers using the amdgpu kernel driver require
            firmware, whether you will be using the xorg amdgpu driver, the
            xserver's modesetting driver, or just kernel modesetting to get a
            console framebuffer larger than 80x25.
          </p>
          <p>
            Install <a class="xref" href="../general/pciutils.html" title=
            "pciutils-3.10.0">pciutils-3.10.0</a> and use that to check the
            model name (look for 'VGA compatible controller:'). If you have
            an APU (Accelerated Processing Unit, i.e. CPU and video on the
            same chip) that will probably tell you the name. If you have a
            separate amdgpu video card you will need to search to determine
            which name it uses (e.g. a card described as Advanced Micro
            Devices, Inc. [AMD/ATI] Baffin [Radeon RX 550 640SP / RX
            560/560X] needs Polaris11 firmware. There is a table of "Family,
            Chipset name, Product name and Firmware" at the end of the Kernel
            sections in <a class="ulink" href=
            "https://wiki.gentoo.org/wiki/AMDGPU#Known_firmware_blobs">AMDGPU</a>
            page of the Gentoo wiki.
          </p>
          <p>
            Once you have identified the firmware name, install all the
            relevant files for it. For example, the Baffin card mentioned
            above has 21 different polaris11* files, APUs such as renoir and
            picasso have at least 12 files and might gain more in future
            updates (e.g. the raven APU now has a 13th file, raven_ta.bin).
          </p>
          <pre class="userinput"><kbd class=
          "command">mkdir -pv /lib/firmware/amdgpu
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/amdgpu</kbd></pre>
          <p>
            If disk space is not a problem, you could install all the current
            amdgpu firmware files and not worry about exactly which chipset
            is installed.
          </p>
          <p>
            Building the kernel amdgpu driver as a module is recommended
            because the firmware files need to be accessible at the time it
            is loaded. If you are building it as a part of the kernel image
            for any reason, you need to either include the firmware files in
            the initramfs (read <a class="xref" href="initramfs.html" title=
            "initramfs について">「initramfs について」</a> for details), or include
            them in the kernel image itself (read <a class="xref" href=
            "firmware.html#firmware-in-kernel-image" title=
            "Include Firmware Blobs in the Kernel Image">「Include Firmware
            Blobs in the Kernel Image」</a> for details).
          </p>
        </div>
        <div class="sect3" lang="ja" xml:lang="ja">
          <h3 class="sect3">
            <a id="nvidia-video-firmware" name="nvidia-video-firmware"></a>
          </h3>
          <h4 class="title">
            <a id="nvidia-video-firmware" name=
            "nvidia-video-firmware"></a>Firmware for Nvidia video chips
          </h4>
          <p>
            Nvidia has released basic signed firmware for recent graphics
            chips, but significantly after the chips and its own binary
            drivers were first available. For other chips it has been
            necessary to extract the firmware from the binary driver.
          </p>
          <p>
            For more exact information about which chips need extracted
            firmware, see <a class="ulink" href=
            "https://nouveau.freedesktop.org/VideoAcceleration.html">https://nouveau.freedesktop.org/VideoAcceleration.html</a>.
          </p>
          <p>
            If the necessary firmware is available in the <code class=
            "filename">nvidia/</code> directory of linux-firmware, copy it to
            <code class="filename">/lib/firmware/nouveau</code>.
          </p>
          <p>
            If the firmware has not been made available in linux-firmware,
            for the old chips mentioned in the nouveau wiki link above run
            the following commands:
          </p>
          <pre class="userinput"><kbd class=
          "command">wget https://anduin.linuxfromscratch.org/BLFS/nvidia-firmware/extract_firmware.py
wget https://us.download.nvidia.com/XFree86/Linux-x86/340.32/NVIDIA-Linux-x86-340.32.run
sh NVIDIA-Linux-x86-340.32.run --extract-only
python3 extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</kbd></pre>
        </div>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="nic-firmware" name="nic-firmware"></a>Firmware for Network
          Interfaces
        </h2>
        <p>
          The kernel likes to load firmware for some network drivers,
          particularly those from Realtek (the /lib/linux-firmware/rtl_nic/)
          directory, but they generally appear to work without it. Therefore,
          you can boot the kernel, check dmesg for messages about this
          missing firmware, and if necessary download the firmware and put it
          in the specified directory in <code class=
          "filename">/lib/firmware</code> so that it will be found on
          subsequent boots. Note that with current kernels this works whether
          or not the driver is compiled in or built as a module, there is no
          need to build this firmware into the kernel. Here is an example
          where the R8169 driver has been compiled in but the firmware was
          not made available. Once the firmware had been provided, there was
          no mention of it on later boots.
        </p>
        <pre class="screen"><code class=
        "literal">dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</code></pre>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="regulatory-db" name="regulatory-db"></a>Firmware for
          Regulatory Database of Wireless Devices
        </h2>
        <p>
          Different countries have different regulations on the radio
          spectrum usage of wireless devices. You can install a firmware to
          make the wireless devices obey local spectrum regulations, so you
          won't be inquired by local authority or find your wireless NIC
          jamming the frequencies of other devices (for example, remote
          controllers). The regulatory database firmware can be downloaded
          from <a class="ulink" href=
          "https://kernel.org/pub/software/network/wireless-regdb/">https://kernel.org/pub/software/network/wireless-regdb/</a>.
          To install it, simply extract <code class=
          "filename">regulatory.db</code> and <code class=
          "filename">regulatory.db.p7s</code> from the tarball into
          <code class="filename">/lib/firmware</code>. Note that either the
          <code class="option">cfg80211</code> driver needs to be selected as
          a module for the <code class="filename">regulatory.*</code> files
          to be loaded, or those files need to be included as firmware into
          the kernel, as explained above in <a class="xref" href=
          "firmware.html#video-firmware" title=
          "Firmware for Video Cards">「Firmware for Video Cards」</a>.
        </p>
        <p>
          The access point (AP) would send a country code to your wireless
          NIC, and <a class="xref" href="../basicnet/wpa_supplicant.html"
          title="wpa_supplicant-2.10">wpa_supplicant-2.10</a> would tell the
          kernel to load the regulation of this country from <code class=
          "filename">regulatory.db</code>, and enforce it. Note that several
          AP don't send this country code, so you may be locked to a rather
          restricted usage (specially if you want to use your interface as an
          AP).
        </p>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="sound-open-firmware" name="sound-open-firmware"></a>Sound
          Open Firmware
        </h2>
        <p>
          Some systems (especially budget laptops) utilizes a DSP shipped
          with the CPU for connection with the audio codec. The Sound Open
          Firmware must be loaded onto the DSP to make it functional. These
          firmware files can be downloaded from <a class="ulink" href=
          "https://github.com/thesofproject/sof-bin/releases">https://github.com/thesofproject/sof-bin/releases</a>.
          Extract the tarball and changing into the extracted directory, then
          as the <code class="systemitem">root</code> user install the
          firmware:
        </p>
        <pre class="userinput"><kbd class=
        "command">install -vdm755 /usr/lib/firmware/intel    &amp;&amp;
cp -av -T --no-preserve=ownership sof      \
   /usr/lib/firmware/intel/sof             &amp;&amp;
cp -av -T --no-preserve=ownership sof-tplg \
   /usr/lib/firmware/intel/sof-tplg</kbd></pre>
        <p>
          <a class="xref" href="../multimedia/alsa-lib.html" title=
          "alsa-lib-1.2.10">alsa-lib-1.2.10</a> needs Use Case Manager
          configuration files for the systems using Sound Open Firmware as
          well. The ALSA UCM configuration files can be downloaded from
          <a class="ulink" href=
          "https://www.alsa-project.org/files/pub/lib/alsa-ucm-conf-1.2.10.tar.bz2">
          https://www.alsa-project.org/files/pub/lib/alsa-ucm-conf-1.2.10.tar.bz2</a>.
          Extract the tarball and changing into the extracted directory, then
          as the <code class="systemitem">root</code> user install the
          configuration files:
        </p>
        <pre class="userinput"><kbd class=
        "command">install -vdm755 /usr/share/alsa &amp;&amp;
cp -av -T --no-preserve=ownership ucm2 /usr/share/alsa/ucm2</kbd></pre>
        <p>
          Once the firmware is loaded (you may need a reboot so the kernel
          will load them) and the UCM configuration files are installed,
          following <a class="xref" href=
          "../multimedia/alsa-utils.html#alsa-utils-config-sect" title=
          "ALSA Utilities の設定">「ALSA Utilities の設定」</a> to set up your sound
          card for ALSA properly.
        </p>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="other-firmware" name="other-firmware"></a>Firmware for Other
          Devices
        </h2>
        <p>
          Identifying the correct firmware will typically require you to
          install <a class="xref" href="../general/pciutils.html" title=
          "pciutils-3.10.0">pciutils-3.10.0</a>, and then use <strong class=
          "userinput"><code>lspci</code></strong> to identify the device. You
          should then search online to check which module it uses, which
          firmware, and where to obtain the firmware — not all of it is in
          linux-firmware.
        </p>
        <p>
          If possible, you should begin by using a wired connection when you
          first boot your LFS system. To use a wireless connection you will
          need to use a network tools such as <a class="xref" href=
          "../basicnet/iw.html" title="iw-5.19">iw-5.19</a>, <a class="xref"
          href="../basicnet/wireless_tools.html" title=
          "Wireless Tools-29">Wireless Tools-29</a>, or <a class="xref" href=
          "../basicnet/wpa_supplicant.html" title=
          "wpa_supplicant-2.10">wpa_supplicant-2.10</a>.
        </p>
        <p>
          Firmware may also be needed for other devices such as some SCSI
          controllers, bluetooth adaptors, or TV recorders. The same
          principles apply.
        </p>
      </div>
      <div class="sect2" lang="ja" xml:lang="ja">
        <h2 class="sect2">
          <a id="firmware-in-kernel-image" name=
          "firmware-in-kernel-image"></a>Include Firmware Blobs in the Kernel
          Image
        </h2>
        <p>
          Some drivers, notably the drivers for ATI or AMD GPU, requires the
          firmware files accessible at the time it is loaded. The easiest
          method to handle these drivers is building them as a kernel module.
          An alternative method is creating an initramfs (read <a class=
          "xref" href="initramfs.html" title="initramfs について">「initramfs
          について」</a> for details) including the firmware files. If you don't
          want to use either methods, you may include the firmware files in
          the kernel image itself. Install the needed firmware files into
          <code class="filename">/lib/firmware</code> first, then set the
          following kernel configuration and rebuild the kernel:
        </p>
        <pre class="screen"><span class="blue">D</span>evice Drivers ---&gt;
  <span class="blue">G</span>eneric Driver Options ---&gt;
    <span class="blue">F</span>irmware loader ---&gt;
      &lt;*&gt;                   <span class=
"blue">F</span>irmware loading facility                [FW_LOADER]
      (xx/aa.bin xx/bb.bin)   <span class=
"blue">B</span>uild named firmware blobs into the kernel binary
                                                           ...  [EXTRA_FIRMWARE]
      (/lib/firmware)           <span class=
"blue">F</span>irmware blobs root directory
                                                       ...  [EXTRA_FIRMWARE_DIR]</pre>
        <p>
          Replace <em class="replaceable"><code>xx/aa.bin
          xx/bb.bin</code></em> with a whitespace-separated list of paths to
          the needed firmware files, relative to <code class=
          "filename">/lib/firmware</code>. A method easier than manually
          typing the list (it may be long) is running the following command:
        </p>
        <pre class="userinput"><kbd class=
        "command">echo CONFIG_EXTRA_FIRMWARE='"'$({ cd /lib/firmware; echo <em class=
        "replaceable"><code>amdgpu/*</code></em> })'"' &gt;&gt; .config
make oldconfig</kbd></pre>
        <p>
          Replace <em class="replaceable"><code>amdgpu/*</code></em> with a
          shell pattern matching the needed firmware files.
        </p>
        <div class="admon warning">
          <img alt="[警告]" src="../images/warning.png" />
          <h3>
            警告
          </h3>
          <p>
            Do not distribute a kernel image containing the firmware to
            others or you may violate the GPL.
          </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="console-fonts.html" title=
          "About Console Fonts">戻る</a>
          <p>
            About Console Fonts
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="devices.html" title="デバイスに関して">次へ</a>
          <p>
            デバイスに関して
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="config.html" title=
          "第3章 LFS 設定以降について">上に戻る</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Beyond Linux® From Scratch    (System V 版) - Version r12.0-1048+">ホーム</a>
        </li>
      </ul>
    </div>
  </body>
</html>
